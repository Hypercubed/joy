#+TITLE:  learning joy
#+AUTHOR: 謝宇恆 \ XIE Yuheng
#+EMAIL:  xyheme@gmail.com

* 源起
** 歷史
   * I enrolled in Psychology and Philosophy because
     "I wanted to know how the human mind works".
     But rats and stats in Psychology and logic and scientific method in Philosophy
     quickly changed my directions.
     In particular,
     I became interested in the justification of induction,
     and I wrote my PhD in the field of inductive logic and logical probability.
     and do deductive logic and programming
   * backus' FP
     <can programming be liberated from the von neumann style>
     no assignable variables
     no formal parameters
   * schoenfinkel's and curry's combinatory logic
     no formal parameters
   * quine's predicate functors
     no variables of quantification
   * tarski's cylindric algebras
** 演繹歷史
   * 函數與函數寫到一併就是函數的複合
     這很自然
     然而對於 棄 複 躍 藏 換 這類操作卻不然
     爲了獲得統一的理解
     把整個棧當成單一的參數即可
   * 但是這是不過是一種理解方式而已
     並不助於編程
     因爲
     在這種理解方式下
     所獲得的結合代數的性質太一般了
   * 只有引入其他的技巧才能讓這種理解方式變得有用
** 函數 之 作用 和 複合 和 定義
   * 在蟬語中
     如果希望的話
     你還是可以退回到
     joy 的作者所發現的
     純粹函數複合的語義
   * 函數 function 作用 參數 value
     #+begin_src cicada-nymph
     value <:x (function)
     value (function)
     #+end_src
   * 函數 gunction 與 function 複合
     #+begin_src cicada-nymph
     <:x (gunction) <:x (function)
     (gunction) (function)
     #+end_src
   * 可以被理解爲 消息傳遞
     因爲函數名是可以被高度重載的
     圓圈中的是函數的 主名
     三角形中的是函數的 輔名
     同樣的 主名 和 輔名
     之於 不同數據類型的參數的時候
     所調用的實際的處理函數也不同
   * 需要有一個機制能夠進行精確的判斷
     編譯時 判斷嫩否直接把函數作用處理掉
     運行時 判斷應該調用那個函數來處理棧裏的參數
   * 函數的定義的特點是
     定義一個函數的時候必須給出很多信息
     也許我需要一個一致的方式在函數中包含各種信息
     當需要 代入語義 的時候我要能夠形成 代入語義
     而其他的時候我要能夠單純地使用簡單的棧處理函數
     也就是真正的局部變量和僞局部變量都可以使用
     但是這合理嗎 ?
     我必須這樣設計
     在這裏沒有對一致性的追求可言
     #+begin_src cicada-nymph
     ><><><
     [ (function) :x ]
     #+end_src
   * 其實就是回到我之前爲 lambda-calculus 設計的語法而已
     只不過需要把對函數的定義設計地更豐富
   * 是否去把表達函數的東西定義爲一種特殊的數據類型呢 ?
     當然要如此
     要知道 對於類型系統
     我有對函數名的註冊呢
     如果是這樣
     那麼就必須把這個數據類型明顯的表達出來
     才能讓數據被初始化之後能夠帶有類型標籤
     應該如何呢 ?
     使用 { } ?
     使用 (type) 之類的函數 ?
     首先我已經決定要使用 [ ] 了
     那麼就許應該設計一種機制
     在單純使用 [ ] 這個括號的同時
     也能初始化多種書角結構
     比如 [ <type-tag>  ... ]
     [ <graph>  ... ]
     而一般的鏈表就是 [ 1 2 3 ]
     [或者把默認的數據結構設爲 <graph>]
     這樣我就獲得了一致的初始化各種類型的數據的語法
     [ <word> ... ] 靜態的數據類型也一樣
     注意此時在使用虛擬機之後
     更多的數據類型是在動態的鏈表中實現的了
** 對特殊語義的批判
   * 比如 APL
     被稱爲 向量處理語言
     在我看來就是
     去識別出某些使用一般語義的模式
     然後就這些使用方式高度優化其語法而已
     ruby 的 code-block 也一樣
     haskell 的 monad 也一樣
     在一般性更強的語義下很容易把這些概念說清楚
   * 既然我認爲我的語言具有最一般的語義[之一[之二是lambda-calculus]]
     那麼我就可以再設計好基本語義之後
     對其他的語言做一次系統的批判
   * 也是說在一個語言中
     去把某些使用基本語義的模式抽象出來
     沒有什麼不好
     這正是最好的編程方式
     因爲嘗試去抽象出 某種使用基本語義的方式 的決策過程
     就是去以一種方式 透徹地理解你所處理的問題 的過程
     [當然每種基本語義模式都代表了一種理解問題的思路[或解決問題的方式]]
   * 而在設計語言的過程中
     重要的是
     提供 恰當的 基本語義
     還有 靈活的 組合基本語義的方式
     這正是 scheme [SICP] 所教我的
   * 在 joy 中 組合子的有限性其實並不是大問題
     只要提供定義新的組合子的方式就行了
     重要的是
     joy 中 代入語義 的缺失
     這樣
     在函數體形成了嵌套的時候
     就沒辦法把同一個變量代入到
     那些形成着嵌套的
     不同層次的 函數體中
     curry 解決這種問題的方式是
     去消去 lambda-abstraction
     但是這種解法只是爲了在堆理論的討論中
     揭示系統的某些性質而已
     很容易看出這種處理方式
     是不可能在編程中被實際使用的
     [也許可以作爲一種 編譯的技術]
     [但是這裏討論的是 表達的技術 屬不同的範疇]
** 對語言之實現的批判
   * joy 的設計者和貢獻者們
     5 年所能做出的工作
     我 3 個月 就能完成
     所以從 joy 上
     我只學一些形而上的東西而已
* 組合子
** 正名
   * joy 的作者的定義
     combinators are second (or even higher) order functions
     which take first (or higher) order functions as parameters
   * curry 的定義
     組合子 是不含自由變元的 lambda-term
   * joy 的作者 如是說
     forth 中的棧處理函數 是爲了把參數調整好 以讓函數們按人們的希望去組合並作用
     curry 的組合子 也一樣
     church 的 lambda 中的約束變元 也一樣
     [有趣的是 對棧中參數的低級處理 和高級的高階函數等價]
     我還可以加一句
     xie 的圖中的 箭頭 和 連線 也一樣
   * 並且要知道
     並沒有更雜的 組合子 與 lambda-term
     他們其實就是在描述函數的組合方式而已
     比如 map 這種函數看似是更高級的
     但是其實它是 loop 而已
     而 loop 是可以用 尾部遞歸函數 實現的
     而遞歸函數是可以用組合子來表達的
     而組合子不過是一個沒有自由變元的 lambda-term 而已
     而沒有自由變元的 lambda-term 只是在描述函數的組合方式而已
   * 但是
     爲了實現 map
     其實還必須要使用到
     基本的 鏈表 處理函數
     但是要知道
     就連鏈表這個數據結構
     也是可以用
     [某種意義上退化的] lambda-term 來編碼的
     之所以說是 退化的
     是因爲 lambda-term 作爲圖的結構
     本來就要比鏈表豐富很多
** 語法
   * joy 中的組合非常值得學習
     但是注意
     下面的語法並不是蟬語中最後敲定的語法
     而是簡單的語法實驗而已
   #+begin_src cicada-nymph
   << in joy :
    *   [if-part]
    *   [then-part]
    *   [else-part] ifte
    >>

   << in cicada >>
   [ ... ] <:if
   [ ... ] <:then
   [ ... ] <:else
   (ifte)

   [ ... ] <:if
   [ ... ] <:then
   [ ... ] <:rec1
   [ ... ] <:rec2
   (linrec)

   << quicksort  >>
   [ small ] <:if
   [ ] <:then
   [ uncons [ > ] split ] <:rec1
   [ swapd cons concat ] <:rec2
   (binrec)

   << 在下面的例子中
    * 應該用 list 來實現 stack 這個事實變得很顯了
    >>

   [ 2 3 ] <:temporary-stack
   [ + 4 5 * ] <:function-body
   (infra)
     ==>
   [ 5 20 ]

   n <:how-many-to-leave-out
   [ ... ] <:function-body
   (dip)
   #+end_src
* data type
  #+begin_src cicada-nymph

  #+end_src
* 簡單介紹
** 基本數據類型
   #+begin_src cicada-nymph
   1     null . << false >>
   0     null . << true >>
   true  null . << false >>
   false null . << true >>


   2  3  +  dup  * .

   [ 1 2 3 ] [ 4 5 6 7 ] concat .

   << 也就是說 "." 這個詞是對所有數據類型的實用的 >>

   [ 3.14  42  [ 1 2 3 ]  0.003 ]   dup  concat .

   [ dup * ] .

   [ 1 2 3 4 ]  [ dup * ]  map .



   20  3  4  +  *  6  -  100  rem .
   3.14     314.0     3.14E5    3.14e-5 .
   'A  32  +  succ  succ .
   false  true  false  not  and  not  or .
   'A  'E  <  2  3  +  15  3  /  =  and .


   help .
   manual .

   << set of 0 ... 31 >>
   { 1 3 5 7 1 3 5 7 1 3 5 7 1 3 5 7 } .
   { 1 3 5 7 }
   { 2 4 6 8 }  or .
   { 3 7 5 1 }
   { 5 4 6 8 }  and .


   "John Smith"   [ 'Z > ]   filter

   [ 1 2 3 ]  0  [ + ]        fold
   [ 1 2 3 ]  0  [ dup * + ]  fold




   DEFINE
       square  ==  dup * ;
       cube    ==  dup dup * * .

   DEFINE
       factorial ==
         [ 0 = ]
         [ pop 1 ]
         [ dup 1 - factorial * ]
         ifte .
   <<
    * <:if
    * <:then
    * <:else
    * (ifte)
    >>

   DEFINE
       factorial ==
         [ 1 ]
         [ * ]
         primrec .


    n     <:次數
    [ 1 ] <:基礎值
    [ * ] <:二元函數
    (primrec)


   3 factorial .


     3  [ 1 ] [ * ]  primrec .
     1  1 2 3 * * * .




   [ 1 2 3 4 5 6 7 8 9 ]
   [ [ 0 = ]
     [ pop 1 ]
     [ dup pred ]
     << recursion occurs between the two rec-parts >>
     [ * ]
     linrec ]
   map .



    <:if
    <:then
    <:rec1
    <:rec2
    (linrec)


   [ 8 1 2 3 0 9 7 5 6 4 ]
   [ small ]
   [ ]
   [ uncons [ > ] split ]
   [ swapd cons concat ]
   binrec .



   [ 1 2 3 4 ] [ + * ] infra .
   #+end_src
